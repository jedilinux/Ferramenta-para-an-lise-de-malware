# -*- coding: utf-8 -*-
# @Autor: Diego Rodrigues Pereira

import os
import pefile
import struct
import math
import binascii
import requests
import json

filename = "malware.exe"  # Aqui va o nome do malware
# Os  arquivo filename pode colocar os seguinte
# filename = '2074e09abed1da51af2e7c073aeb8b5c'  # Exemplo de MD5 hash
# filename = '/path/to/document.pdf'  # Exemplo de arquivo PDF
# filename = 'C:\\Windows\\System32\\user32.dll'  # Exemplo de arquivo DLL
# filename = '/path/to/document.docx'  # Exemplo de arquivo DOCX

api_key = ""

# Função para calcular a entropia de uma sequência de bytes
def entropy(data):
    if not data:
        return 0
    entropy = 0
    for x in range(256):
        p_x = float(data.count(x))/len(data)
        if p_x > 0:
            entropy += - p_x * math.log(p_x, 2)
    return entropy

# Função para imprimir informações sobre um arquivo PE
def print_pe_info(filename):
    pe = pefile.PE(filename)

    print("\n[*] SESSÕES DO PE:")
    for section in pe.sections:
        print("\tNome da sessão: %s" % section.Name.decode().rstrip('\x00'))
        print("\tEndereço virtual: %s" % hex(section.VirtualAddress))
        print("\tTamanho da sessão: %s" % hex(section.Misc_VirtualSize))
        print("\tTamanho dos dados brutos: %s" % hex(section.SizeOfRawData))
        print("\tMD5: %s" % section.get_hash_md5())

    print("\n[*] FUNÇÕES IMPORTADAS:")
    for entry in pe.DIRECTORY_ENTRY_IMPORT:
        print("\t%s" % entry.dll.decode().rstrip('\x00'))
        for imp in entry.imports:
            print("\t\t%s" % imp.name.decode().rstrip('\x00'))

    print("\n[*] FUNÇÃO EXPORTADA:")
    try:
        exports = pe.DIRECTORY_ENTRY_EXPORT.symbols
        for export in exports:
            print("\t%s" % export.name.decode().rstrip('\x00'))
    except AttributeError:
        print("\tNenhuma função exportada encontrada.")

    print("\n[*] SOBREPOSIÇÃO:")
    if pe.sections:
        file_offset = pe.sections[-1].get_file_offset()
        end_of_sections = file_offset + len(pe.sections)*40
        if end_of_sections < os.path.getsize(filename):
            overlap_size = os.path.getsize(filename) - end_of_sections
            print("\tTamanho da sobreposição: %s bytes" % overlap_size)
            print("\tHexdump da sobreposição:\n")
            with open(filename, 'rb') as f:
                f.seek(end_of_sections)
                data = f.read(overlap_size)
                print(binascii.hexlify(data))
        else:
            print("\tNenhuma sobreposição encontrada.")

    print("\n[*] RELATÓRIO AV DO VIRUSTOTAL:")
    api_key = "" # adicione sua chave da API do VirusTotal aqui
if api_key:
    params = {'apikey': api_key, 'resource': filename}
    response = requests.get('https://www.virustotal.com/vtapi/v2/file/report', params=params, headers=headers)
    try:
        response_json = json.loads(response.content.decode())
        if response_json['response_code'] == 0:
            print("\tArquivo não encontrado no VirusTotal.")
        else:
            for antivirus, result in response_json['scans'].items():
                if result['detected']:
                    print("\t%s: %s" % (antivirus, result['result']))
    except json.JSONDecodeError:
        print("\tErro ao decodificar a resposta JSON do VirusTotal.")
else:
    print("\tErro ao enviar arquivo para o VirusTotal.") 
